<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Color Block Shooter</title>
<style>
  body {
    margin:0;
    background:#0e0f12;
    display:flex;
    justify-content:center;
    align-items:center;
    height:100vh;
    font-family:sans-serif;
    color:#bfc8d6;
  }
  .wrap {
    width:100%;
    max-width:420px;
    aspect-ratio:9/16;
    background: linear-gradient(to bottom, #101216, #04070c);
    border-radius: 20px;
    overflow: hidden;
    display:flex;
    flex-direction:column;
    box-shadow: 0 0 20px rgba(0,0,0,0.8);
  }
  header {
    display:flex;
    justify-content:center;
    padding:12px;
    color:#ffb86b;
    font-weight:bold;
    font-size:18px;
    text-shadow: 0 0 5px #ffb86b;
  }
  canvas {
    flex:1;
    width:100%;
    height:100%;
    touch-action:none;
    display:block;
  }
  .controls {
    display:flex;
    justify-content:center;
    gap:12px;
    padding:10px;
  }
  button {
    background: #222731;
    color: #fff;
    border:none;
    border-radius: 12px;
    padding:10px 16px;
    font-weight:600;
    font-size:14px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.5);
    transition: 0.2s;
  }
  button:hover { background:#2c3445; cursor:pointer; }
</style>
</head>
<body>
<div class="wrap">
  <header id="score">Score: 0</header>
  <canvas id="game"></canvas>
  <div class="controls">
    <button id="start">Start</button>
    <button id="restart">Restart</button>
  </div>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
let W,H;
const DPR = window.devicePixelRatio || 1;
function resize(){
  const rect = canvas.getBoundingClientRect();
  W = rect.width; H = rect.height;
  canvas.width = W*DPR; canvas.height = H*DPR;
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener("resize",resize);
resize();

const colors = ["#60a5fa","#ff6b6b","#ffd86b"];
const ballRadius = 20;
const blockRadius = 20;
const rows = 6, cols = 7;
const blockSpacing = 5;
let grid = [];
let shooterBall = null;
let running=false;
let score=0;
let lastTime=0;

// Initialize blocks
function generateGrid(){
  grid=[];
  for(let r=0;r<rows;r++){
    const row=[];
    for(let c=0;c<cols;c++){
      row.push({color:colors[Math.floor(Math.random()*colors.length)], x:c, y:r});
    }
    grid.push(row);
  }
}

// Shooter ball
function newShooterBall(){
  const color = colors[Math.floor(Math.random()*colors.length)];
  shooterBall = {x: W/2, y: H-50, color, vx:0, vy:0, moving:false};
}

// Shooting
canvas.addEventListener("pointerdown", e=>{
  if(!running || shooterBall.moving) return;
  const rect = canvas.getBoundingClientRect();
  const dx = (e.clientX - rect.left) - shooterBall.x;
  const dy = (e.clientY - rect.top) - shooterBall.y;
  const angle = Math.atan2(dy,dx);
  const speed = 600;
  shooterBall.vx = Math.cos(angle)*speed;
  shooterBall.vy = Math.sin(angle)*speed;
  shooterBall.moving=true;
});

// Remove only same color blocks recursively
function removeConnectedBlocks(r,c,color){
  if(r<0||c<0||r>=grid.length||c>=grid[0].length) return;
  const block = grid[r][c];
  if(!block || block.color!==color) return;
  grid[r][c]=null;
  score+=10;
  removeConnectedBlocks(r+1,c,color);
  removeConnectedBlocks(r-1,c,color);
  removeConnectedBlocks(r,c+1,color);
  removeConnectedBlocks(r,c-1,color);
}

// Update
function update(dt){
  if(shooterBall.moving){
    shooterBall.x += shooterBall.vx*dt;
    shooterBall.y += shooterBall.vy*dt;

    // Collision with blocks
    outer: for(let r=0;r<grid.length;r++){
      for(let c=0;c<cols;c++){
        const block = grid[r][c];
        if(!block) continue;
        const bx = block.x*(blockRadius*2+blockSpacing)+blockRadius+10;
        const by = block.y*(blockRadius*2+blockSpacing)+blockRadius+50;
        const dx = shooterBall.x-bx;
        const dy = shooterBall.y-by;
        const dist = Math.sqrt(dx*dx+dy*dy);
        if(dist < blockRadius*2){
          if(shooterBall.color === block.color){
            removeConnectedBlocks(r,c,block.color);
          }
          shooterBall.moving=false;
          newShooterBall();
          break outer;
        }
      }
    }

    if(shooterBall.y<-ballRadius){
      shooterBall.moving=false;
      newShooterBall();
    }
  }

  // Infinite blocks: add new row if top row empty
  if(grid[0].every(b=>b===null)){
    const newRow=[];
    for(let c=0;c<cols;c++){
      newRow.push({color:colors[Math.floor(Math.random()*colors.length)],x:c,y:0});
    }
    grid.unshift(newRow);
    // Move rows down
    for(let r=1;r<grid.length;r++){
      for(let c=0;c<cols;c++){
        if(grid[r][c]) grid[r][c].y=r;
      }
    }
    if(grid.length>rows) grid.pop();
  }
}

// Draw
function draw(){
  ctx.fillStyle = "#0b1220";
  ctx.fillRect(0,0,W,H);

  for(let r=0;r<grid.length;r++){
    for(let c=0;c<cols;c++){
      const block = grid[r][c];
      if(!block) continue;
      const bx = block.x*(blockRadius*2+blockSpacing)+blockRadius+10;
      const by = block.y*(blockRadius*2+blockSpacing)+blockRadius+50;
      ctx.fillStyle = block.color;
      ctx.beginPath();
      ctx.arc(bx,by,blockRadius,0,Math.PI*2);
      ctx.fill();
    }
  }

  if(shooterBall){
    ctx.fillStyle = shooterBall.color;
    ctx.beginPath();
    ctx.arc(shooterBall.x,shooterBall.y,ballRadius,0,Math.PI*2);
    ctx.fill();
  }

  document.getElementById("score").textContent = "Score: "+score;
}

// Loop
function loop(timestamp){
  if(!running) return;
  const dt = (timestamp-lastTime)/1000;
  lastTime=timestamp;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

// Start / restart
function startGame(){
  running=true;
  lastTime=performance.now();
  score=0;
  generateGrid();
  newShooterBall();
  loop(lastTime);
}
function restartGame(){ startGame(); }

document.getElementById("start").onclick=startGame;
document.getElementById("restart").onclick=restartGame;

draw();
</script>
</body>
</html>
